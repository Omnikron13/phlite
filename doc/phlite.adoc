= PHLITE(7)
Joey Sabey <GameFreak7744@gmail.com>
v0.1.0
:doctype: manpage
:compat-mode:
:manmanual: Phlite Manual
:mansource: Phlite
//left alignment fails with asciidoc, requiring asciidoctor
:toc: left
//3 levels might be preferable, but produces too large a toc without left alignment
:toclevels: 2


== NAME
phlite - a lightweight PHP user authentication and permission library


== SYNOPSIS
Phlite is a PHP library designed to facilitate the creation of SQLite based websites which require user authentication and variable user permissions.


== DESCRIPTION
The primary API is provided by the *User*, *Group* and *Lock* classes:

* *User* provides functionaliy for user management, login/authentication and CSRF prevention.
* *Group* provides functionality for categorising users into user groups.
* *Lock* provides functionality to facilitate restricting access to areas or actions to certain users and/or user groups.

Ancillary functionality is provided by the *DB* and *Config* classes:

* *DB* provides access to the database file via a 'PDO' instance.
* *Config* is used to load configuration files at the start of scripts/pages using *Phlite*.

Additional utility & low level functionality is provided by the *Base64*, *Cookie*, *RequestToken* and *Session* classes.
These classes likely do not need to be used directly.

The library as a whole can be loaded by simply including the 'Phlite.php' file, which pulls in the classes as dependencies and declares top-level functions.


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== User API

=== ID

==== getID() : int

Returns the unique *id* of the user.


=== Username

==== $user->getUsername() : string

Returns the *username* of the user.


==== $user->setUsername(string $username) : void

Updates the user's *username* in the database.
Throws a *UserException* with code *102* if '$username' is invalid, code *103* if unavailable.
See *validUsername()* & *availableUsername()* for more details.


==== User::validUsername(string $username) : bool

Returns *true* if '$username' is a valid username, otherwise *false*.
Validity is determined by a regex loaded from the *username_regex* parameter in the *[user]* section of config files.


==== User::availableUsername(string $username) : bool

Returns *false* if '$username' is a username in use already in the database, otherwise returns *true*.


=== Email

==== $user->getEmail() : string

Returns the *email* of the user.


==== $user->setEmail(string $email) : void

Updates the user's *email* in the database.
Throws a *UserException* with code *104* if '$email' is invalid, code *105* if unavailable.
See *validEmail()* & *availableEmail()* for more details.


==== User::validEmail(string $email) : bool

Returns *true* if '$email' is a \'valid' email, otherwise *false*.
Validity is determined by a regex loaded from the *email_regex* parameter in the *[user]* section of config files.


==== User::availableEmail(string $email) : bool

Returns *false* if '$email' is an email in use already in the database, otherwise returns *true*.


=== Password

==== $user->setPassword(string $password) : void

Updates the user's *password* in the database.
The password is currently always hashed with the 'BCRYPT' algorithm with the cost being controlled by the *password_hash_cost* config parameter under the *[user]* section.
Throws a *UserException* with code *106* if '$password' is invalid.
See *validPassword()* for more details.


==== $user->checkPassword(string $password) : bool

Returns *true* if '$password' matches the stored hash, *false* otherwise.


==== User::validPassword(string $password) : bool

Returns *true* if '$password' is a valid password, otherwise *false*.
Validity is determined by a regex loaded from the *password_regex* parameter in the *[user]* section of config files.


=== Misc

==== getRegisterTime() : int

Returns a UNIX timestamp of the time the user was added to the database.


=== Login

==== User::login(string $username, string $password) : array

Attempts to start a new session for the user specified by '$username', authenticating with '$password'.
If successful cookie headers will be sent meaning this function must be called before any output.
Returns an array with details of the login attempt.
The *success* key is a boolean which is *true* on successful logins, *false* on failures.

For failures there will be an *code* key indicating the reason the login attempt failed with one of the codes from the *User::LOGIN_ERROR[]* array.
Possible codes are;
'NO_USERNAME',
'NO_PASSWORD',
'NO_SUCH_USER',
'INCORRECT_PASSWORD',
'USER_IN_COOLDOWN' &
'FREQUENCY_EXCEEDED'

For successes there will be a *user* key containing a *User* object represnting the logged in user, along with a *session* key containing an id:key string.


==== User::logout() : void

Ends any session currently associated with the browser accessing the page it is called from.
This function needs to send cookie headers and so must be called before any output.


=== CSRF Protection

==== $user->generateRequestToken() : string

Returns a token which can be used in HTML forms to protect against 'CSRF' attacks.
Config parameters for request tokens are in the *[request_token]* section of config files:

* *max* controls how many request tokens can be active and valid for each user simultaneously.
* *bytes* controls how many pseudo-random bytes are used to generate the token.
* *hash_cost* controls the cost parameter of the hashing algorithm (currently always 'BCRYPT') used to hash the token before storing it in the database.
* *ttl* controls the number of seconds (from script execution time) that tokens will be considered valid for.


==== $user->checkRequestToken(string $token) : bool

Returns *true* if '$token' matches any tokens generated previously for the user with *generateRequestToken()*.
Returns *false* if the token has timed out (exceeded the *ttl*) or does not match.
Once a token has been used once it is removed from the database and subsequent attempts to verify it will return *false*.


=== User Management

==== __construct(int $id)

The *User* constructor accepts the *id* of a user in the database as '$id'.
If no user with that id can be found it will throw a *UserException* with code *101*.


==== User::add(string $username, string $password, string $email) : User

Attempts to add a new user to the database with the '$username', '$email' and '$password' provided, returning a *User* object representing the new user.
Throws a *UserException* on failure with one of the following codes:

* *102* - invalid username
* *103* - unavailable username
* *104* - invalid email address
* *105* - unavailable email address
* *106* - invalid password

See
*validUsername()*,
*availableUsername()*,
*validEmail()*,
*availableEmail()* &
*validPassword()*
for more details.


==== $user->remove() : void

Removes the user from the database.


==== User::getCurrent() : ?User

Returns either a *User* object representing the currently logged in user, or *NULL* if no user is logged in.


==== User::getAll() : array

Returns an array of *User* objects representing all users in the database.


==== User::getByID(int $id) : ?User

Returns a *User* representing the user referenced by '$id', or *NULL* if no user with that id found.


==== User::getByUsername(string $username) : ?User

Returns a *User* representing the user referenced by '$username', or *NULL* if no user with that username found.


==== User::getByEmail(string $email) : ?User

Returns a *User* representing the user referenced by '$email', or *NULL* if no user with that email found.


=== Database

==== User::setupDB() : void

Loads database schemas for the
*users*,
*users_verify*,
*users_sessions*,
*users_logins* &
*users_request_tokens*
tables from the following schema files:

* 'sql/users.sql'
* 'sql/users_verify.sql'
* 'sql/users_sessions.sql'
* 'sql/users_logins.sql'
* 'sql/users_request_tokens.sql'


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== Group API

=== ID

==== $group->getID() : int

Returns the unique *id* of the group.


=== Name

==== $group->getName() : string

Returns the *name* of the group.


==== $group->setName(string $name) : void

Updates the group's *name* in the database.
Throws a *GroupException* with code *202* if '$name' is invalid, *203* if unavailable.
See *validName()* & *availableName()* for more details.


==== Group::validName(string $name) : bool

Returns *true* if '$name' is a valid group name, otherwise *false*.
Validity is determined by a regex loaded from the *name_regex* parameter in the *[group]* section of config files.


==== Group::availableName(string $name) : bool

Returns *false* if '$name' is a group name in use already in the database, otherwise *true*.


=== Description

==== $group->getDescription() : string

Returns the *description* of the group.


==== $group->setDescription(string $description) : void

Updates the group's *description* in the database.
Throws a *GroupException* with code *204* if '$description' is invalid.
See *validDescription()* for more details.


==== Group::validDescription(string $description) : bool

Returns *true* if '$description' is a valid group description, otherwise *false*.
Validity is determined by a regex loaded from the *description_regex* parameter in the *[group]* section of config files.


=== Group Management

==== __construct(int $id)

The *Group* constructor accepts the *id* of a group in the database as '$id'.
If no group with that id can be found it will throw a *GroupException* with code *201*.


==== Group::add(string $name, ?string $description = NULL) : Group

Attempts to add a new group to the database with the '$name' and '$description' provided, returning a *Group* object representing the new group.
Throws a *GroupException* on failute with one of the following codes:

* *202* - invalid group name
* *203* - unavailable group name
* *204* - invalid group description

See
*validName()*,
*availableName()* &
*validDescription()*
for more details.


==== $group->remove() : void

Removes the group from the database.


==== Group::getAll() : array

Returns an array of *Group* objects representing all groups in the database.


==== Group::getByID(int $id) : ?Group

Returns a *Group* representing the group referenced by '$id', or *NULL* if no group with that id found.


//TODO: move this if it gets changed to User->getGroups() in source
==== Group::getUserGroups(User $user) : array

Returns an array of *Group* objects representing all groups which '$user' is a member of.


=== Member Management

==== $group->addMember(User $user) : void

Adds '$user' to the group in the database.


==== $group->getMembers() : array

Returns an array of *User* objects representing the group's members.


==== $group->containsMember(User $user) : bool

Returns *true* if group contains '$user', otherwise *false*.


==== $group->removeMember(User $user) : void

Removes '$user' from the group in the database.


=== Database

==== Group::setupDB() : void

Loads database schemas for the
*groups* &
*groups_members*
tables from the following schema files:

* 'sql/groups.sql'
* 'sql/groups_members.sql'


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== Lock API

=== ID

==== $lock->getID() : int

Returns the unique *id* of the lock.


=== Name

==== $lock->getName() : string

Returns the *name* of the lock.


==== $lock->setName(string $name) : void

Updates the lock's *name* in the database.
Throws a *LockException* with code *302* if '$name' is invalid, code *303* if unavailable.
See *validName()* & *availableName()* for more details.


==== Lock::validName(string $name) : bool

Returns *true* if '$name' is a valid lock name, otherwise *false*.
Validity is determined by a regex loaded from the *name_regex* parameter in the *[lock]* section of config files.


==== Lock::availableName(string $name) : bool

Returns *false* if '$name' is a lock name in use already in the database, otherwise *true*.


=== Description

==== $lock->getDescription() : string

Returns the *description* of the lock.


==== $lock->setDescription(string $description) : void

Updates the lock's *description* in the database.
Throws a *LockException* with code *304* if '$description' is invalid.
See *validDescription()* for more details.


==== Lock::validDescription(string $description) : bool

Returns *true* if '$description' is a valid lock description, otherwise *false*.
Validity is determined by a regex loaded from the *description_regex* parameter in the *[lock]* section of config files.


=== Lock Management

==== __construct(int $id)

The *Lock* constructor accepts the *id* of a lock in the database as '$id'.
If no lock with that id can be found it will throw a *LockException* with code *301*.


==== Lock::add(string $name, ?string $description = NULL) : Lock

Attempts to add a new lock to the database with the '$name' and '$description' provided, returning a *Lock* object representing the new lock.
Throws a *LockException* on failure with one of the following codes:

* *302* - invalid lock name
* *303* - unavailable lock name
* *304* - invalid lock description

See
*validName()*,
*availableName()* &
*validDescription()*
for more details.


==== $lock->remove() : void

Removes the lock from the database.


==== Lock::getAll() : array

Returns an array of *Lock* objects representing all locks in the database.


==== Lock::getByID(int $id) : ?Lock

Returns a *Lock* representing the lock referenced by '$id', or *NULL* if no lock with that id found.


=== Key Management

==== $lock->grantGroupKey(Group $group) : void

Registers '$group' as having a \'key' to this lock in the 'locks_group_keys' table of the database.
This allows the group to be verified with *checkGroupKey()* (and its members to be verified with *checkUserKey()*).


==== $lock->checkGroupKey(Group $group) : bool

Returns *true* if '$group' is registered as having a \'key' to this lock in the 'locks_group_keys' table in the database, otherwise *false*.


==== $lock->revokeGroupKey(Group $group) : void

Removes the \'key' for this lock registered for '$group' in the 'locks_group_keys' table in the database (if one exists).


==== $lock->getGroups() : array

Returns an array of groups that hold a \'key' to this lock in the 'locks_group_keys' table of the database.


==== $lock->grantUserKey(User $user) : void

Registers '$user' as having a \'key' to this lock in the 'locks_user_keys' table of the database.
This allows the user to be verified with *checkUserKey()*.


==== $lock->checkUserKey(User $user, bool $checkGroups = true) : bool

Returns *true* if '$user' is registered as having a \'key' to this lock in the 'locks_user_keys' table in the database.
Additionally returns *true* if '$checkGroups' is set to *true* and any of the groups the user is a member of are registered as having a key in the 'locks_group_keys' table.
Returns *false* otherwise.


==== $lock->revokeUserKey(User $user) : void

Removes the \'key' for this lock registered for '$user' in the 'locks_user_keys' table in the database (if one exists).


==== $lock->getUsers(bool $includeGroups = false) : array

Returns an array of users that hold a \'key' to this lock in the 'locks_user_keys' table of the database.
Additionally if '$includeGroups' is set to *true* users that are members of groups that are registered as holding \'keys' in the 'locks_group_keys' table will also be included in the array.


=== Database

==== Lock::setupDB() : void

Loads database schemas for the
*locks*,
*locks_group_keys* &
*locks_user_keys*
tables from the following schema files:

* 'sql/locks.sql'
* 'sql/locks_group_keys.sql'
* 'sql/locks_user_keys.sql'


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== Miscellaneous API

=== Top-level Functions

==== setupDB() : void

This function will create all database tables, indexes, etc. that are required by 'Phlite' by calling the *setupDB()* static methods of necessary classes.
As such this function needs to be called once to initalise the database before most methods will function.
Please note however that *Config::load()* should obviously be called 'before' this function so the database path will be correct.


=== DB API

==== DB::get() : PDO

Returns a 'PDO' object allowing access to the database.


==== DB::prepare(string $sql) : PDOStatement

Convenience method to prepare an SQL statement for the database.


==== DB::exec(string $sql) : int

Convenience method to execute an SQL statement which does not expect any returned data on the database.
Implemented as a pass-through to an *exec()* call on the underlying 'PDO' object representing the database, including the returned integer.


==== DB::execFile(string $file) : int

Reads the file specified by '$file' (which may be anywhere in the include path) and passes it through to *DB::exec()*.


=== Config API

==== Config::load(?string $file = NULL) : void

Loads configuration parameters from the file identified by '$file' (which may reside anywhere in the include path).
Note that the default parameters from 'defaults.cfg' will be loaded first, and calls to this method patch over those defaults, allowing for partial (and perhaps multiple) config files.

If '$file' is set to *NULL* (and no config is already loaded) then 'defaults.cfg' will be loaded, but nothing else is done.
You do not have to call the method this way yourself.


==== Config::get(string $section, string $param) : mixed

Returns the value of the config parameter specified by '$param' from the section specified by '$section'.


=== Cookie API

==== Cookie::send(string $key, ?string $value, ?int $duration = NULL) : void

Sends out a cookie keyed by '$key' with a value of '$value'.
The '$duration' parameter defines how long (in seconds, from now) the cookie remains valid.
If '$duration' is *NULL* then the duration is defined by the *default_ttl* parameter in the *[cookie]* section of config files.
Other config parameters which control cookies are
*path*,
*domain*,
*secure* &
*http_only*.
Note that as this method sends headers it must be called before output to function.


==== Cookie::clear(string $key) : void

Clears the cookie identified by '$key'.
Note that as this method sends headers it must be called before output to function.


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== Exceptions

.UserException
|======================================================
|Code |Name                 |Message

|101  |USER_NOT_FOUND       |User not found
|102  |USERNAME_INVALID     |Invalid username
|103  |USERNAME_UNAVAILABLE |Unavailable username
|104  |EMAIL_INVALID        |Invalid email address
|105  |EMAIL_UNAVAILABLE    |Unavailable email address
|106  |PASSWORD_INVALID     |Invalid password
|======================================================


.GroupException
|======================================================
|Code |Name                 |Message

|201  |GROUP_NOT_FOUND      |Group not found
|202  |NAME_INVALID         |Invalid group name
|203  |NAME_UNAVAILABLE     |Unavailable group name
|204  |DESCRIPTION_INVALID  |Invalid group description
|======================================================


.LockException
|======================================================
|Code |Name                 |Message

|301  |LOCK_NOT_FOUND       |Lock not found
|302  |NAME_INVALID         |Invalid lock name
|303  |NAME_UNAVAILABLE     |Unavailable lock name
|304  |DESCRIPTION_INVALID  |Invalid lock description
|======================================================


.SessionException
|======================================================
|Code |Name                 |Message

|401  |SESSION_NOT_FOUND    |Session not found
|======================================================


.RequestTokenException
|======================================================
|Code |Name                 |Message

|501  |TOKEN_NOT_FOUND      |Request token not found
|======================================================


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== COPYRIGHT

Copyright (C) 2017 Joey Sabey <GameFreak7744@gmail.com>

Phlite is licensed under the MIT licence, a copy of which is included in the 'LICENCE' file.


