= PHLITE(7)
Joey Sabey <joey.sabey@gmx.com>
v0.1.0
:doctype: manpage
:compat-mode:
:manmanual: Phlite Manual
:mansource: Phlite
//left alignment fails with asciidoc, requiring asciidoctor
:toc: left
//3 levels might be preferable, but produces too large a toc without left alignment
:toclevels: 2


== NAME
phlite - a lightweight PHP user authentication and permission library


== SYNOPSIS
Phlite is a PHP library designed to facilitate the creation of SQLite based websites which require user authentication and variable user permissions.


== DESCRIPTION
The primary API is provided by the *User*, *Group* and *Lock* classes:

* *User* provides functionaliy for user management, login/authentication and CSRF prevention.
* *Group* provides functionality for categorising users into user groups.
* *Lock* provides functionality to facilitate restricting access to areas or actions to certain users and/or user groups.

Ancillary functionality is provided by the *DB* and *Config* classes:

* *DB* provides access to the database file via a 'PDO' instance.
* *Config* is used to load configuration files at the start of scripts/pages using *Phlite*.

Additional utility & low level functionality is provided by the *Email*, *Base64*, *Cookie*, *RequestToken* and *Session* classes.
These classes likely do not need to be used directly.

The library as a whole can be loaded by simply including the 'Phlite.php' file, which pulls in the classes as dependencies and declares top-level functions.


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== User API

=== ID

==== getID() : int

Returns the unique *id* of the user.


=== Username

==== $user->getUsername() : string

Returns the *username* of the user.


==== $user->setUsername(string $username) : void

Updates the user's *username* in the database.
Throws a *UserException* with code *102* if '$username' is invalid, code *103* if unavailable.
See *validUsername()* & *availableUsername()* for more details.


==== User::validUsername(string $username) : bool

Returns *true* if '$username' is a valid username, otherwise *false*.
Validity is determined by a regex loaded from the *username_regex* parameter in the *[user]* section of config files.


==== User::availableUsername(string $username) : bool

Returns *false* if '$username' is a username in use already in the database, otherwise returns *true*.


=== Email

==== $user->getEmail() : string

Returns the *email* of the user.


==== $user->setEmail(string $email) : void

Updates the user's *email* in the database.
Throws a *UserException* with code *104* if '$email' is invalid, code *105* if unavailable.
See *validEmail()* & *availableEmail()* for more details.


==== $user->sendVerifyEmail() : void

Sends a verification email to the user.
The *subject*, *from* and *reply-to* headers are pulled from the respective parameters in the *[email_verify]* section of config files.
The plaintext and HTML body is generated from templates pointed to by the *plaintext_template* and *html_template* parameters,
with the url identified by the *url* parameter inserted where the *url_token* appears (appended with the user ID and a token generated by *generateEmailVerifyToken()* as GET parameters).
The verification is completed by the user visiting the url, which should contain a script calling *verifyEmail()*.


==== $user->emailVerified() : bool
Returns *true* if the user has verified their email address, *false* otherwise.
Specifically, it returns *true* if there is no entry in the 'users_verify' table of the database for this user;
if no token was ever generated for the user (with *generateEmailVerifyToken()* or *sendVerifyEmail()*) then it will still return *true* (this allows users to be manually added without requiring verification).


==== $user->verifyEmail(string $token) : bool

Returns *true* if '$token' matches that stored in the 'users_verify' table for this user, otherwise *false*.
If returning *true* the row for this user will also be cleared from the table and subsequent calls to *emailVerified()* will return *true*.
Throws a *UserException* with code *107* if the user appears to have already verified their email.
See *generateEmailVerifyToken()* or *sendVerifyEmail()* for generating tokens.


==== $user->generateEmailVerifyToken() : string

Generates and returns a token (in 'base64url' encoding) that can be used to verify a user has control of their registered email address.
Its size (in bytes) is controlled by the *bytes* parameter in the *[email_verify]* section of config files.
If an entry already exists for this user in the 'users_verify' table of the database, it is overwritten and the old token will become invalid.
This method is useful if you wish to manually send out verification emails with custom email code, email libraries, etc.
See *sendVerifyEmail()* for an alternative, and *verifyEmail()* for the verification step.


==== User::validEmail(string $email) : bool

Returns *true* if '$email' is a \'valid' email, otherwise *false*.
Validity is determined by a regex loaded from the *email_regex* parameter in the *[user]* section of config files.


==== User::availableEmail(string $email) : bool

Returns *false* if '$email' is an email in use already in the database, otherwise returns *true*.


=== Password

==== $user->setPassword(string $password) : void

Updates the user's *password* in the database.
The password is hashed with the algorithm specified by the *password_hash_algorithm* config parameter under the *[user]* section, which accepts any options available to PHP's *password_hash()* function.
Options for the hashing algorithm (primarily for controlling the cost) are specified in the *password_hash_options[]* array in the *[user]* section of config files, and again are all of those accepted by PHP's *password_hash()* function for the algorithm being used.
Throws a *UserException* with code *106* if '$password' is invalid.
See *validPassword()* for more details.


==== $user->checkPassword(string $password) : bool

Returns *true* if '$password' matches the stored hash, *false* otherwise.


==== User::validPassword(string $password) : bool

Returns *true* if '$password' is a valid password, otherwise *false*.
Validity is determined by a regex loaded from the *password_regex* parameter in the *[user]* section of config files.


=== Misc

==== getRegisterTime() : int

Returns a UNIX timestamp of the time the user was added to the database.


=== Login

==== User::login(string $username, string $password) : array

Attempts to start a new session for the user specified by '$username', authenticating with '$password'.
If successful cookie headers will be sent meaning this function must be called before any output.
Returns an array with details of the login attempt.
The *success* key is a boolean which is *true* on successful logins, *false* on failures.

For failures there will be an *code* key indicating the reason the login attempt failed with one of the codes from the *User::LOGIN_ERROR[]* array.
Possible codes are;
'NO_USERNAME',
'NO_PASSWORD',
'NO_SUCH_USER',
'INCORRECT_PASSWORD',
'USER_IN_COOLDOWN' &
'FREQUENCY_EXCEEDED'

For successes there will be a *user* key containing a *User* object represnting the logged in user, along with a *session* key containing an id:key string.


==== User::logout() : void

Ends any session currently associated with the browser accessing the page it is called from.
This function needs to send cookie headers and so must be called before any output.


=== CSRF Protection

==== $user->generateRequestToken() : string

Returns a token which can be used in HTML forms to protect against 'CSRF' attacks.
Config parameters for request tokens are in the *[request_token]* section of config files:

* *max* controls how many request tokens can be active and valid for each user simultaneously.
* *bytes* controls how many pseudo-random bytes are used to generate the token.
* *hash_algorithm* controls which hashing algorithm is used to hash the token before storing it in the database. Available options are those available to PHP's *password_hash()* function.
* *hash_options* controls details of the hashing algorithm, primarily hashing cost. Again available options are those available to PHP's *password_hash()* function, as applicable to the chosen algorithm.
* *ttl* controls the number of seconds (from script execution time) that tokens will be considered valid for.


==== $user->checkRequestToken(string $token) : bool

Returns *true* if '$token' matches any tokens generated previously for the user with *generateRequestToken()*.
Returns *false* if the token has timed out (exceeded the *ttl*) or does not match.
Once a token has been used once it is removed from the database and subsequent attempts to verify it will return *false*.


=== User Management

==== __construct(int $id)

The *User* constructor accepts the *id* of a user in the database as '$id'.
If no user with that id can be found it will throw a *UserException* with code *101*.


==== User::add(string $username, string $password, string $email) : User

Attempts to add a new user to the database with the '$username', '$email' and '$password' provided, returning a *User* object representing the new user.
Throws a *UserException* on failure with one of the following codes:

* *102* - invalid username
* *103* - unavailable username
* *104* - invalid email address
* *105* - unavailable email address
* *106* - invalid password

See
*validUsername()*,
*availableUsername()*,
*validEmail()*,
*availableEmail()* &
*validPassword()*
for more details.


==== $user->remove() : void

Removes the user from the database.


==== User::getCurrent() : ?User

Returns either a *User* object representing the currently logged in user, or *NULL* if no user is logged in.


==== User::getAll() : array

Returns an array of *User* objects representing all users in the database.


==== User::getByID(int $id) : ?User

Returns a *User* representing the user referenced by '$id', or *NULL* if no user with that id found.


==== User::getByUsername(string $username) : ?User

Returns a *User* representing the user referenced by '$username', or *NULL* if no user with that username found.


==== User::getByEmail(string $email) : ?User

Returns a *User* representing the user referenced by '$email', or *NULL* if no user with that email found.


=== Database

==== User::setupDB() : void

Loads database schemas for the
*users*,
*users_verify*,
*users_sessions*,
*users_logins* &
*users_request_tokens*
tables from the following schema files:

* 'sql/users.sql'
* 'sql/users_verify.sql'
* 'sql/users_sessions.sql'
* 'sql/users_logins.sql'
* 'sql/users_request_tokens.sql'


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== Group API

=== ID

==== $group->getID() : int

Returns the unique *id* of the group.


=== Name

==== $group->getName() : string

Returns the *name* of the group.


==== $group->setName(string $name) : void

Updates the group's *name* in the database.
Throws a *GroupException* with code *202* if '$name' is invalid, *203* if unavailable.
See *validName()* & *availableName()* for more details.


==== Group::validName(string $name) : bool

Returns *true* if '$name' is a valid group name, otherwise *false*.
Validity is determined by a regex loaded from the *name_regex* parameter in the *[group]* section of config files.


==== Group::availableName(string $name) : bool

Returns *false* if '$name' is a group name in use already in the database, otherwise *true*.


=== Description

==== $group->getDescription() : ?string

Returns the *description* of the group.


==== $group->setDescription(?string $description) : void

Updates the group's *description* in the database.
Throws a *GroupException* with code *204* if '$description' is invalid.
See *validDescription()* for more details.


==== Group::validDescription(?string $description) : bool

Returns *true* if '$description' is a valid group description, otherwise *false*.
Validity is determined by a regex loaded from the *description_regex* parameter in the *[group]* section of config files.


=== Group Management

==== __construct(int $id)

The *Group* constructor accepts the *id* of a group in the database as '$id'.
If no group with that id can be found it will throw a *GroupException* with code *201*.


==== Group::add(string $name, ?string $description = NULL) : Group

Attempts to add a new group to the database with the '$name' and '$description' provided, returning a *Group* object representing the new group.
Throws a *GroupException* on failute with one of the following codes:

* *202* - invalid group name
* *203* - unavailable group name
* *204* - invalid group description

See
*validName()*,
*availableName()* &
*validDescription()*
for more details.


==== $group->remove() : void

Removes the group from the database.


==== Group::getAll() : array

Returns an array of *Group* objects representing all groups in the database.


==== Group::getByID(int $id) : ?Group

Returns a *Group* representing the group referenced by '$id', or *NULL* if no group with that id found.


//TODO: move this if it gets changed to User->getGroups() in source
==== Group::getByUser(User $user) : array

Returns an array of *Group* objects representing all groups which '$user' is a member of.


=== Member Management

==== $group->addMember(User $user) : void

Adds '$user' to the group in the database.


==== $group->getMembers() : array

Returns an array of *User* objects representing the group's members.


==== $group->containsMember(User $user) : bool

Returns *true* if group contains '$user', otherwise *false*.


==== $group->removeMember(User $user) : void

Removes '$user' from the group in the database.


=== Database

==== Group::setupDB() : void

Loads database schemas for the
*groups* &
*groups_members*
tables from the following schema files:

* 'sql/groups.sql'
* 'sql/groups_members.sql'


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== Lock API

=== ID

==== $lock->getID() : int

Returns the unique *id* of the lock.


=== Name

==== $lock->getName() : string

Returns the *name* of the lock.


==== $lock->setName(string $name) : void

Updates the lock's *name* in the database.
Throws a *LockException* with code *302* if '$name' is invalid, code *303* if unavailable.
See *validName()* & *availableName()* for more details.


==== Lock::validName(string $name) : bool

Returns *true* if '$name' is a valid lock name, otherwise *false*.
Validity is determined by a regex loaded from the *name_regex* parameter in the *[lock]* section of config files.


==== Lock::availableName(string $name) : bool

Returns *false* if '$name' is a lock name in use already in the database, otherwise *true*.


=== Description

==== $lock->getDescription() : ?string

Returns the *description* of the lock.


==== $lock->setDescription(?string $description) : void

Updates the lock's *description* in the database.
Throws a *LockException* with code *304* if '$description' is invalid.
See *validDescription()* for more details.


==== Lock::validDescription(?string $description) : bool

Returns *true* if '$description' is a valid lock description, otherwise *false*.
Validity is determined by a regex loaded from the *description_regex* parameter in the *[lock]* section of config files.


=== Lock Management

==== __construct(int $id)

The *Lock* constructor accepts the *id* of a lock in the database as '$id'.
If no lock with that id can be found it will throw a *LockException* with code *301*.


==== Lock::add(string $name, ?string $description = NULL) : Lock

Attempts to add a new lock to the database with the '$name' and '$description' provided, returning a *Lock* object representing the new lock.
Throws a *LockException* on failure with one of the following codes:

* *302* - invalid lock name
* *303* - unavailable lock name
* *304* - invalid lock description

See
*validName()*,
*availableName()* &
*validDescription()*
for more details.


==== $lock->remove() : void

Removes the lock from the database.


==== Lock::getAll() : array

Returns an array of *Lock* objects representing all locks in the database.


==== Lock::getByID(int $id) : ?Lock

Returns a *Lock* representing the lock referenced by '$id', or *NULL* if no lock with that id found.


==== Lock::getByGroup(Group $group) : array

Returns an array of *Lock* objects representing all locks which '$group' holds \'keys' for.


==== Lock::getByUser(User $user, bool $includeGroups = true) : array

Returns an array of *Lock* objects representing all locks which '$user' holds \'keys' for.
If '$includeGroups' is set to *true* then locks for which groups the user is a member of hold \'keys' for are included in the array.


=== Key Management

==== $lock->grantGroupKey(Group $group) : void

Registers '$group' as having a \'key' to this lock in the 'locks_group_keys' table of the database.
This allows the group to be verified with *checkGroupKey()* (and its members to be verified with *checkUserKey()*).


==== $lock->checkGroupKey(Group $group) : bool

Returns *true* if '$group' is registered as having a \'key' to this lock in the 'locks_group_keys' table in the database, otherwise *false*.


==== $lock->revokeGroupKey(Group $group) : void

Removes the \'key' for this lock registered for '$group' in the 'locks_group_keys' table in the database (if one exists).


==== $lock->getGroups() : array

Returns an array of groups that hold a \'key' to this lock in the 'locks_group_keys' table of the database.


==== $lock->grantUserKey(User $user) : void

Registers '$user' as having a \'key' to this lock in the 'locks_user_keys' table of the database.
This allows the user to be verified with *checkUserKey()*.


==== $lock->checkUserKey(User $user, bool $checkGroups = true) : bool

Returns *true* if '$user' is registered as having a \'key' to this lock in the 'locks_user_keys' table in the database.
Additionally returns *true* if '$checkGroups' is set to *true* and any of the groups the user is a member of are registered as having a key in the 'locks_group_keys' table.
Returns *false* otherwise.


==== $lock->revokeUserKey(User $user) : void

Removes the \'key' for this lock registered for '$user' in the 'locks_user_keys' table in the database (if one exists).


==== $lock->getUsers(bool $includeGroups = false) : array

Returns an array of users that hold a \'key' to this lock in the 'locks_user_keys' table of the database.
Additionally if '$includeGroups' is set to *true* users that are members of groups that are registered as holding \'keys' in the 'locks_group_keys' table will also be included in the array.


=== Database

==== Lock::setupDB() : void

Loads database schemas for the
*locks*,
*locks_group_keys* &
*locks_user_keys*
tables from the following schema files:

* 'sql/locks.sql'
* 'sql/locks_group_keys.sql'
* 'sql/locks_user_keys.sql'


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== Miscellaneous API

=== Top-level Functions

==== setupDB() : void

This function will create all database tables, indexes, views, etc. that are required by 'Phlite' by calling the *setupDB()* static methods of necessary classes.
As such this function needs to be called once to initalise the database before most methods will function.
Please note however that *Config::load()* should obviously be called 'before' this function so the database path will be correct.


=== DB API

==== DB::get() : PDO

Returns a 'PDO' object allowing access to the database.


==== DB::prepare(string $sql) : PDOStatement

Convenience method to prepare an SQL statement for the database.


==== DB::exec(string $sql) : int

Convenience method to execute an SQL statement which does not expect any returned data on the database.
Implemented as a pass-through to an *exec()* call on the underlying 'PDO' object representing the database, including the returned integer.


==== DB::execFile(string $file) : int

Reads the file specified by '$file' (which may be anywhere in the include path) and passes it through to *DB::exec()*.


=== Config API

==== Config::load(?string $file = NULL) : void

Loads configuration parameters from the file identified by '$file' (which may reside anywhere in the include path).
Note that the default parameters from 'defaults.cfg' will be loaded first, and calls to this method patch over those defaults, allowing for partial (and perhaps multiple) config files.

If '$file' is set to *NULL* (and no config is already loaded) then 'defaults.cfg' will be loaded, but nothing else is done.
You do not have to call the method this way yourself.


==== Config::get(string $section, string $param) : mixed

Returns the value of the config parameter specified by '$param' from the section specified by '$section'.


=== Cookie API

==== Cookie::send(string $key, ?string $value, ?int $duration = NULL) : void

Sends out a cookie keyed by '$key' with a value of '$value'.
The '$duration' parameter defines how long (in seconds, from now) the cookie remains valid.
If '$duration' is *NULL* then the duration is defined by the *default_ttl* parameter in the *[cookie]* section of config files.
Other config parameters which control cookies are
*path*,
*domain*,
*secure* &
*http_only*.
Note that as this method sends headers it must be called before output to function.


==== Cookie::clear(string $key) : void

Clears the cookie identified by '$key'.
Note that as this method sends headers it must be called before output to function.


=== Base64 API

==== Base64::encode(string $s) : string

Encodes a string in the 'base64url' format (as described by RFC 4648).


==== Base64::decode(string $s) : string

Decodes a string that has been encoded in the 'base64url' format (as described by RFC 4648).


=== Email API

==== __construct(string $to, string $subject='')

The *Email* constructor accepts the email address to send to as '$to' and optionally the subject as '$subject'.


==== $email->setPlaintext(string $plaintext) : void

Sets the plaintext part of the email to the '$plaintext' provided.
Note that this class always sends multipart emails which may appear blank if the *setHTML()* method is not also called.


==== $email->setHTML(string $html) : void

Sets the HTML part of the email to the '$html' provided.
Note that this class always sends multipart emails which may appear blank if the *setPlaintext()* method is not also called.


==== $email->setHeader(string $key, string $value) : void

Sets an arbitrary header key : value pair for the email to '$key' : '$value'.


==== $email->send() : void

Sends the email, via the standard PHP *mail()* function.


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== Exceptions

.UserException
|======================================================
|Code |Name                 |Message

|101  |USER_NOT_FOUND       |User not found
|102  |USERNAME_INVALID     |Invalid username
|103  |USERNAME_UNAVAILABLE |Unavailable username
|104  |EMAIL_INVALID        |Invalid email address
|105  |EMAIL_UNAVAILABLE    |Unavailable email address
|106  |PASSWORD_INVALID     |Invalid password
|107  |ALREADY_VERIFIED     |Email already verified
|======================================================


.GroupException
|======================================================
|Code |Name                 |Message

|201  |GROUP_NOT_FOUND      |Group not found
|202  |NAME_INVALID         |Invalid group name
|203  |NAME_UNAVAILABLE     |Unavailable group name
|204  |DESCRIPTION_INVALID  |Invalid group description
|======================================================


.LockException
|======================================================
|Code |Name                 |Message

|301  |LOCK_NOT_FOUND       |Lock not found
|302  |NAME_INVALID         |Invalid lock name
|303  |NAME_UNAVAILABLE     |Unavailable lock name
|304  |DESCRIPTION_INVALID  |Invalid lock description
|======================================================


.SessionException
|======================================================
|Code |Name                 |Message

|401  |SESSION_NOT_FOUND    |Session not found
|======================================================


.RequestTokenException
|======================================================
|Code |Name                 |Message

|501  |TOKEN_NOT_FOUND      |Request token not found
|======================================================


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

== COPYRIGHT

Copyright (C) 2017-2019 Joey Sabey <joey.sabey@gmx.com>

Phlite is licensed under the MIT licence, a copy of which is included in the 'LICENCE' file.


